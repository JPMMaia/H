import * as vscode from "vscode";

import * as Core from "../utilities/coreModelInterface";
import * as Default_grammar from "../core/Default_grammar";
import * as Grammar from "../core/Grammar";
import * as Parse_tree_convertor from "../core/Parse_tree_convertor";
import * as Parser from "../core/Parser";
import * as Scanner from "../core/Scanner";
import * as Symbol_database from "../core/Symbol_database";
import * as Text_formatter from "../core/Text_formatter";

import * as H_document_provider from "./H_document_provider";
import { onThrowError } from "../utilities/errors";

export class H_file_system_provider implements vscode.FileSystemProvider {

    private onDidChangeFileEventEmitter: vscode.EventEmitter<vscode.FileChangeEvent[]> = new vscode.EventEmitter<vscode.FileChangeEvent[]>();
    public onDidChangeFile: vscode.Event<vscode.FileChangeEvent[]> = this.onDidChangeFileEventEmitter.event;

    private h_document_provider: H_document_provider.H_document_provider;

    constructor(h_document_provider: H_document_provider.H_document_provider) {
        this.h_document_provider = h_document_provider;
    }

    public watch(uri: vscode.Uri, options: { recursive: boolean; excludes: string[]; }): vscode.Disposable {
        return new vscode.Disposable(() => { });
    }

    public stat(uri: vscode.Uri): vscode.FileStat | Thenable<vscode.FileStat> {
        const file_uri = uri.with({ scheme: "file" });
        return vscode.workspace.fs.stat(file_uri);
    }

    public readDirectory(uri: vscode.Uri): [string, vscode.FileType][] | Thenable<[string, vscode.FileType][]> {
        const file_uri = uri.with({ scheme: "file" });
        return vscode.workspace.fs.readDirectory(file_uri);
    }

    public createDirectory(uri: vscode.Uri): void | Thenable<void> {
        const file_uri = uri.with({ scheme: "file" });
        return vscode.workspace.fs.createDirectory(file_uri);
    }

    public async readFile(uri: vscode.Uri): Promise<Uint8Array> {

        const file_uri = uri.with({ scheme: "file" });

        const file_data = await vscode.workspace.fs.readFile(file_uri);
        const utf8_data = Buffer.from(file_data).toString("utf8");
        const json_data = JSON.parse(utf8_data);

        const module: Core.Module = json_data as Core.Module;
        const symbol_database = Symbol_database.create_edit_database(module);

        const grammar_description = Default_grammar.create_description();
        const production_rules = Grammar.create_production_rules(grammar_description);

        const declarations = Parse_tree_convertor.create_declarations(module);
        const initial_parse_tree = Parse_tree_convertor.module_to_parse_tree(module, symbol_database, declarations, production_rules);
        const text = Text_formatter.to_string(initial_parse_tree);
        const encoded_text = Buffer.from(text, "utf8");

        {
            const map_word_to_terminal = (word: Grammar.Word): string => {
                if (word.value === "enum" || word.value === "export" || word.value === "function" || word.value === "module" || word.value === "struct" || word.value === "using") {
                    return word.value;
                }

                if (word.type === Grammar.Word_type.Alphanumeric) {
                    return "identifier";
                }

                return word.value;
            };

            const parsing_tables = Grammar.create_parsing_tables_from_production_rules(production_rules);
            const scanned_words = Scanner.scan(text, 0, text.length);
            const parse_tree = Parser.parse(scanned_words, parsing_tables.action_table, parsing_tables.go_to_table, map_word_to_terminal);

            if (parse_tree === undefined) {
                const message = "Could not parse text generated by module! Internal error!";
                onThrowError(message);
                throw Error(message);
            }

            const document_data: H_document_provider.H_document = {
                module: module,
                production_rules: production_rules,
                map_word_to_terminal: map_word_to_terminal,
                parse_tree: parse_tree,
                symbol_database: symbol_database
            };
            this.h_document_provider.set_document(uri, document_data);
        }

        return await Promise.resolve(encoded_text);
    }

    public writeFile(uri: vscode.Uri, content: Uint8Array, options: { create: boolean; overwrite: boolean; }): void | Thenable<void> {

        const document_data = this.h_document_provider.get_document(uri);
        if (document_data === undefined) {
            throw vscode.FileSystemError.FileNotFound(uri);
        }

        const file_uri = uri.with({ scheme: "file" });

        const json_data = JSON.stringify(document_data.module);
        const file_data: Uint8Array = Buffer.from(json_data, "utf8");

        return vscode.workspace.fs.writeFile(file_uri, file_data);
    }

    public delete(uri: vscode.Uri, options: { recursive: boolean; }): void | Thenable<void> {
        const file_uri = uri.with({ scheme: "file" });
        return vscode.workspace.fs.delete(file_uri, options);
    }

    public rename(old_uri: vscode.Uri, new_uri: vscode.Uri, options: { overwrite: boolean; }): void | Thenable<void> {
        const old_file_uri = old_uri.with({ scheme: "file" });
        const new_file_uri = new_uri.with({ scheme: "file" });
        return vscode.workspace.fs.rename(old_file_uri, new_file_uri, options);
    }

    public copy?(source: vscode.Uri, destination: vscode.Uri, options: { overwrite: boolean; }): void | Thenable<void> {
        const source_uri = source.with({ scheme: "file" });
        const destination_uri = destination.with({ scheme: "file" });
        return vscode.workspace.fs.copy(source_uri, destination_uri, options);
    }
}
